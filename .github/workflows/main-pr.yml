# Copyright 2025 Neuraville Inc.
# SPDX-License-Identifier: Apache-2.0

name: Main PR Tests

on:
  pull_request:
    branches: [ main ]
    types: [opened, synchronize, reopened, ready_for_review]

env:
  CARGO_TERM_COLOR: always

# Least-privilege: PR test workflow must not have write permissions.
permissions:
  contents: read

jobs:
  comprehensive-tests:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout PR code
      uses: actions/checkout@v4
    
    - name: Check branch name format
      run: |
        BRANCH_NAME="${{ github.event.pull_request.head.ref }}"
        echo "Source branch name: $BRANCH_NAME"
        
        # Check if branch name follows "Pre-Main: X.Y.Z" format
        if [[ ! "$BRANCH_NAME" =~ ^Pre-Main:\ ([0-9]+\.[0-9]+\.[0-9]+)$ ]]; then
          echo "‚ùå Error: Branch name must follow format 'Pre-Main: X.Y.Z'"
          echo "Current branch name: $BRANCH_NAME"
          echo "Expected format: Pre-Main: 2.0.1"
          exit 1
        fi
        
        BRANCH_VERSION="${BASH_REMATCH[1]}"
        echo "Version from branch name: $BRANCH_VERSION"
        
        # Get version from Cargo.toml
        CARGO_VERSION=$(grep '^version = ' Cargo.toml | head -1 | sed 's/version = "\(.*\)"/\1/')
        echo "Version from Cargo.toml: $CARGO_VERSION"
        
        # Ensure branch version matches Cargo.toml version
        if [ "$BRANCH_VERSION" != "$CARGO_VERSION" ]; then
          echo "‚ùå Error: Branch name version must match Cargo.toml version"
          echo "Branch version: $BRANCH_VERSION"
          echo "Cargo.toml version: $CARGO_VERSION"
          exit 1
        fi
        
        echo "‚úÖ Branch name format is valid: $BRANCH_NAME"
    
    - name: Check version number increase
      run: |
        echo "‚ÑπÔ∏è  Note: With independent versioning, each crate has its own version"
        echo "   This check validates workspace.package version only"
        echo ""
        
        # Get current workspace version from PR branch (HEAD)
        CURRENT_VERSION=$(grep '^\[workspace\.package\]' -A 10 Cargo.toml | grep '^version = ' | head -1 | sed 's/version = "\(.*\)"/\1/')
        if [ -z "$CURRENT_VERSION" ]; then
          # Fallback to root package version
          CURRENT_VERSION=$(grep '^version = ' Cargo.toml | head -1 | sed 's/version = "\(.*\)"/\1/')
        fi
        echo "PR workspace version: $CURRENT_VERSION"
        
        # Ensure PR version is semantic only (no beta or other tags)
        if [[ ! "$CURRENT_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          echo "‚ùå Error: Main PR version must be semantic only (X.Y.Z) with no beta tags"
          echo "Current version: $CURRENT_VERSION"
          echo "Expected format: X.Y.Z (e.g., 0.0.1)"
          exit 1
        fi
        
        # Download main branch Cargo.toml directly from GitHub
        echo "Downloading main Cargo.toml..."
        curl -s https://raw.githubusercontent.com/feagi/feagi-core/refs/heads/main/Cargo.toml -o main_cargo.toml
        
        # Get version from main branch
        MAIN_VERSION=$(grep '^\[workspace\.package\]' -A 10 main_cargo.toml | grep '^version = ' | head -1 | sed 's/version = "\(.*\)"/\1/')
        if [ -z "$MAIN_VERSION" ]; then
          MAIN_VERSION=$(grep '^version = ' main_cargo.toml | head -1 | sed 's/version = "\(.*\)"/\1/')
        fi
        echo "Main workspace version: $MAIN_VERSION"
        
        # Clean up temporary file
        rm main_cargo.toml
        
        # Ensure main version is also semantic only (should always be true)
        if [[ ! "$MAIN_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          echo "‚ùå Error: Main branch version should be semantic only (X.Y.Z)"
          echo "Main version: $MAIN_VERSION (something is wrong with main branch)"
          exit 1
        fi
        
        # Compare versions using sort -V (version sort)
        if [ "$CURRENT_VERSION" = "$MAIN_VERSION" ]; then
          echo "‚ùå Error: Workspace version must be increased from main branch"
          echo "PR version: $CURRENT_VERSION, Main version: $MAIN_VERSION"
          exit 1
        fi
        
        # Check if current version is greater than main version
        HIGHER_VERSION=$(printf '%s\n%s\n' "$MAIN_VERSION" "$CURRENT_VERSION" | sort -V | tail -n1)
        if [ "$HIGHER_VERSION" != "$CURRENT_VERSION" ]; then
          echo "‚ùå Error: Workspace version must be higher than main branch"
          echo "PR version: $CURRENT_VERSION, Main version: $MAIN_VERSION"
          exit 1
        fi
        
        echo "‚úÖ Workspace version check passed: $MAIN_VERSION ‚Üí $CURRENT_VERSION"
        echo "‚ÑπÔ∏è  Individual crate versions are managed independently"
    
    - name: Install Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        toolchain: stable
    
    - name: Install additional Rust components
      run: |
        rustup component add clippy rustfmt
    
    - name: Cache cargo registry
      uses: actions/cache@v3
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-cargo-
    
    - name: Check code formatting
      run: cargo fmt --all -- --check
    
    - name: Run Clippy (linting)
      run: cargo clippy --workspace --lib --tests -- -D warnings
    
    - name: Run all tests (lib only, examples have known API migration issues)
      run: cargo test --workspace --lib --verbose
    
    - name: Run Comprehensive Neural Dynamics Tests (CRITICAL)
      working-directory: crates/feagi-npu/burst-engine
      run: |
        echo "::group::Running Comprehensive Neural Dynamics Test Suite"
        echo "‚ö†Ô∏è  CRITICAL: These tests gate merges to main"
        cargo test --test comprehensive_neural_dynamics --no-fail-fast -- --test-threads=1 --nocapture
        echo "::endgroup::"
      
    - name: Run NPU Integration Tests
      working-directory: crates/feagi-npu/burst-engine
      run: |
        echo "::group::Running NPU Integration Tests"
        cargo test --tests --no-fail-fast
        echo "::endgroup::"
    
    - name: Generate Neural Dynamics Test Report
      if: always()
      working-directory: crates/feagi-npu/burst-engine
      run: |
        echo "# Neural Dynamics Test Report" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "## Test Coverage" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        cargo test --test comprehensive_neural_dynamics -- --list | grep "test_" | wc -l | xargs -I {} echo "Total Tests: {}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Test Categories" >> $GITHUB_STEP_SUMMARY
        echo "- Threshold scenarios (PSP <, =, > threshold)" >> $GITHUB_STEP_SUMMARY
        echo "- MP accumulation (true/false)" >> $GITHUB_STEP_SUMMARY
        echo "- Leak coefficients (0.0, 0.5, 1.0)" >> $GITHUB_STEP_SUMMARY
        echo "- PSP uniformity (divide vs full)" >> $GITHUB_STEP_SUMMARY
        echo "- Multiple synapses" >> $GITHUB_STEP_SUMMARY
        echo "- Synapse types (excitatory, inhibitory, mixed)" >> $GITHUB_STEP_SUMMARY
        echo "- Refractory periods" >> $GITHUB_STEP_SUMMARY
        echo "- Complex network scenarios" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "üìã See detailed findings: [TEST_FINDINGS.md](feagi-core/crates/feagi-npu/burst-engine/tests/TEST_FINDINGS.md)" >> $GITHUB_STEP_SUMMARY
    
    - name: Run tests in release mode (lib only)
      run: cargo test --workspace --lib --release --verbose
    
    - name: Check documentation
      run: cargo doc --no-deps --document-private-items
    
    - name: Build in release mode (lib only)
      run: cargo build --release --lib --verbose --workspace --exclude feagi-async
    
    - name: Verify crate metadata for publication
      run: |
        echo "Verifying all crates have required metadata for crates.io..."
        
        # Check that each crate in workspace has required fields
        for crate_dir in crates/*/; do
          if [ -f "$crate_dir/Cargo.toml" ]; then
            crate_name=$(basename "$crate_dir")
            echo "Checking $crate_name..."
            
            # Check for required fields
            if ! grep -q '^description = ' "$crate_dir/Cargo.toml"; then
              echo "‚ùå Missing description in $crate_name"
              exit 1
            fi
            
            if ! grep -q '^license = ' "$crate_dir/Cargo.toml"; then
              echo "‚ùå Missing license in $crate_name"
              exit 1
            fi
            
            echo "‚úÖ $crate_name has required metadata"
          fi
        done
        
        echo "‚úÖ All crates have required metadata for publication"
    
    - name: Dry run package verification
      run: |
        echo "Verifying all workspace crates can be packaged..."
        
        # Package each crate to verify they're ready
        for crate_dir in crates/*/; do
          if [ -f "$crate_dir/Cargo.toml" ]; then
            crate_name=$(basename "$crate_dir")
            echo "Packaging $crate_name..."
            (cd "$crate_dir" && cargo package --quiet)
            echo "‚úÖ $crate_name packages successfully"
          fi
        done
        
        echo "‚úÖ All crates can be packaged successfully"

  agent-sdk-live-contracts:
    name: Agent SDK Live HTTP Contract Tests
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
    - name: Checkout PR code
      uses: actions/checkout@v4

    - name: Install Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        toolchain: stable

    - name: Cache cargo registry
      uses: actions/cache@v3
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-cargo-

    - name: Build FEAGI HTTP API server (example)
      run: |
        set -euo pipefail
        cargo build -p feagi-api --example http_api_server

    - name: Start FEAGI HTTP API server (example) in background
      run: |
        set -euo pipefail
        echo "Starting feagi-api example server..."
        nohup ./target/debug/examples/http_api_server > feagi-api-server.log 2>&1 &
        echo $! > feagi-api-server.pid
        echo "PID: $(cat feagi-api-server.pid)"

    - name: Wait for FEAGI HTTP API server to be ready
      run: |
        set -euo pipefail
        for i in $(seq 1 180); do
          if curl -sf "http://127.0.0.1:8000/swagger-ui/" >/dev/null; then
            echo "Server is ready"
            exit 0
          fi
          sleep 1
        done
        echo "Server did not become ready in time"
        echo "Last 200 lines of server log:"
        tail -200 feagi-api-server.log || true
        exit 1

    - name: Run live HTTP contract tests (feagi-agent)
      env:
        FEAGI_API_HOST: 127.0.0.1
        FEAGI_API_PORT: "8000"
      run: |
        cargo test -p feagi-agent --test live_http_contract_tests --features sdk -- --nocapture

    - name: Upload server log (artifact)
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: feagi-api-server-log
        path: feagi-api-server.log
        if-no-files-found: warn

    - name: Stop FEAGI HTTP API server
      if: always()
      run: |
        set +e
        if [ -f feagi-api-server.pid ]; then
          kill "$(cat feagi-api-server.pid)" 2>/dev/null || true
        fi

  publish-local-sim:
    name: Publish Simulation (local packaged deps gate)
    runs-on: ubuntu-latest
    needs: [comprehensive-tests]
    timeout-minutes: 45
    steps:
    - name: Checkout PR code (full history for diff)
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Install Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        toolchain: stable

    - name: Rust cache
      uses: Swatinem/rust-cache@v2
      with:
        shared-key: "publish-local-sim-main-pr"
        save-if: true

    - name: Compute and apply independent version bumps (CI-only)
      shell: bash
      run: |
        set -euo pipefail

        chmod +x scripts/smart-version-bump.sh
        chmod +x scripts/apply-version-bumps.sh

        VERSION_OUTPUT="$(./scripts/smart-version-bump.sh)"
        echo "${VERSION_OUTPUT}"

        VERSIONS_FILE="$(echo "${VERSION_OUTPUT}" | grep "VERSIONS_FILE=" | cut -d'=' -f2)"
        if [ -z "${VERSIONS_FILE}" ]; then
          echo "‚ùå Failed to detect VERSIONS_FILE from smart-version-bump output"
          exit 1
        fi

        export VERSIONS_FILE="${VERSIONS_FILE}"
        ./scripts/apply-version-bumps.sh

    - name: Package and build published artifacts against local packaged dependencies
      shell: bash
      run: |
        set -euo pipefail

        # This directory is created at runtime in CI only (not committed).
        ROOT="/tmp/feagi_local_publish_sim"
        DRIVER="${ROOT}/driver"
        EXTRACTED="${ROOT}/extracted"
        mkdir -p "${DRIVER}/.cargo" "${EXTRACTED}"

        # Use the publish order baked into the existing smart publish script.
        # Keep this list in sync with scripts/publish-crates-smart.sh CRATE_ORDER.
        CRATE_ORDER=(
          "feagi-observability"
          "feagi-structures"
          "feagi-config"
          "feagi-npu-neural"
          "feagi-npu-runtime"
          "feagi-serialization"
          "feagi-state-manager"
          "feagi-npu-burst-engine"
          "feagi-npu-plasticity"
          "feagi-evolutionary"
          "feagi-brain-development"
          "feagi-sensorimotor"
          "feagi-services"
          "feagi-io"
          "feagi-api"
          "feagi-agent"
          "feagi-hal"
          "feagi"
        )

        crate_path_for() {
          case "$1" in
            feagi-observability) echo "crates/feagi-observability" ;;
            feagi-structures) echo "crates/feagi-structures" ;;
            feagi-config) echo "crates/feagi-config" ;;
            feagi-npu-neural) echo "crates/feagi-npu/neural" ;;
            feagi-npu-runtime) echo "crates/feagi-npu/runtime" ;;
            feagi-serialization) echo "crates/feagi-serialization" ;;
            feagi-state-manager) echo "crates/feagi-state-manager" ;;
            feagi-npu-burst-engine) echo "crates/feagi-npu/burst-engine" ;;
            feagi-npu-plasticity) echo "crates/feagi-npu/plasticity" ;;
            feagi-evolutionary) echo "crates/feagi-evolutionary" ;;
            feagi-brain-development) echo "crates/feagi-brain-development" ;;
            feagi-sensorimotor) echo "crates/feagi-sensorimotor" ;;
            feagi-services) echo "crates/feagi-services" ;;
            feagi-io) echo "crates/feagi-io" ;;
            feagi-api) echo "crates/feagi-api" ;;
            feagi-agent) echo "crates/feagi-agent" ;;
            feagi-hal) echo "crates/feagi-hal" ;;
            feagi) echo "." ;;
            *) return 1 ;;
          esac
        }

        # 0) Patch crates.io to local workspace for packaging validation.
        # This avoids crate resolution failures when new beta versions are not yet published.
        mkdir -p ".cargo"
        PATCH_LOCAL=".cargo/config.toml"
        {
          echo "[patch.crates-io]"
          for crate in "${CRATE_ORDER[@]}"; do
            path="$(crate_path_for "${crate}")" || continue
            [ -f "${path}/Cargo.toml" ] || continue
            echo "${crate} = { path = \"${GITHUB_WORKSPACE}/${path}\" }"
          done
        } > "${PATCH_LOCAL}"

        # 1) Produce .crate packages (manifest will be publish-style: no path/workspace deps).
        for crate in "${CRATE_ORDER[@]}"; do
          path="$(crate_path_for "${crate}")" || continue
          [ -f "${path}/Cargo.toml" ] || continue
          echo "üì¶ cargo package -p ${crate}"
          cargo package --allow-dirty --no-verify --package "${crate}" --quiet
        done

        # 2) Extract packaged sources and build a [patch.crates-io] map to them.
        PATCH_FILE="${DRIVER}/.cargo/config.toml"
        {
          echo "[patch.crates-io]"
        } > "${PATCH_FILE}"

        for crate in "${CRATE_ORDER[@]}"; do
          path="$(crate_path_for "${crate}")" || continue
          [ -f "${path}/Cargo.toml" ] || continue

          version="$(awk -F'"' '/^version = / { print $2; exit }' "${path}/Cargo.toml")"
          if [ -z "${version}" ]; then
            echo "‚ùå Failed to read version for ${crate} from ${path}/Cargo.toml"
            exit 1
          fi

          crate_file="target/package/${crate}-${version}.crate"
          if [ ! -f "${crate_file}" ]; then
            echo "‚ùå Expected package not found: ${crate_file}"
            exit 1
          fi

          dest="${EXTRACTED}/${crate}-${version}"
          rm -rf "${dest}"
          mkdir -p "${dest}"
          tar -xf "${crate_file}" -C "${dest}"

          # The tarball contains a single root folder: <name>-<version>/
          src_dir="${dest}/${crate}-${version}"
          if [ ! -f "${src_dir}/Cargo.toml" ]; then
            echo "‚ùå Extracted package missing Cargo.toml: ${src_dir}/Cargo.toml"
            exit 1
          fi

          echo "${crate} = { path = \"${src_dir}\" }" >> "${PATCH_FILE}"
        done

        echo ""
        echo "‚úÖ Patch map written to: ${PATCH_FILE}"
        echo ""

        # 3) Build each packaged crate against the packaged dependency set.
        # Run from DRIVER so the patch config applies.
        cd "${DRIVER}"

        for crate in "${CRATE_ORDER[@]}"; do
          # Find the extracted dir (we know the version from the repo Cargo.toml)
          path="$(crate_path_for "${crate}")" || continue
          [ -f "${GITHUB_WORKSPACE}/${path}/Cargo.toml" ] || continue

          version="$(awk -F'"' '/^version = / { print $2; exit }' "${GITHUB_WORKSPACE}/${path}/Cargo.toml")"
          manifest="${EXTRACTED}/${crate}-${version}/${crate}-${version}/Cargo.toml"
          if [ ! -f "${manifest}" ]; then
            echo "‚ùå Missing extracted manifest: ${manifest}"
            exit 1
          fi

          echo "üî® Building packaged crate: ${crate} (${version})"
          cargo build --manifest-path "${manifest}" --quiet
        done

        echo ""
        echo "üéâ Local publish simulation build completed successfully."
