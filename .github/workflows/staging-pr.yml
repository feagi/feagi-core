# Copyright 2025 Neuraville Inc.
# SPDX-License-Identifier: Apache-2.0

name: Staging PR Tests

on:
  pull_request:
    branches: [ staging ]
    types: [opened, synchronize, reopened, ready_for_review]

env:
  CARGO_TERM_COLOR: always

# Least-privilege: PR test workflow must not have write permissions.
permissions:
  contents: read

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout PR code
      uses: actions/checkout@v4
    
    - name: Install Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        toolchain: stable
    
    - name: Cache cargo registry
      uses: actions/cache@v3
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-cargo-
    
    - name: Run tests (lib only)
      run: cargo test --workspace --lib --verbose
    
    - name: Run Comprehensive Neural Dynamics Tests
      working-directory: crates/feagi-npu/burst-engine
      run: |
        echo "::group::Running Comprehensive Neural Dynamics Test Suite"
        cargo test --test comprehensive_neural_dynamics --no-fail-fast -- --test-threads=1 --nocapture
        echo "::endgroup::"
        echo "::group::Running Extended Neural Dynamics Tests (Consecutive Limits, Threshold Dynamics)"
        cargo test --test comprehensive_neural_dynamics_extended --no-fail-fast -- --test-threads=1 --nocapture
        echo "::endgroup::"
      
    - name: Run NPU Integration Tests
      working-directory: crates/feagi-npu/burst-engine
      run: |
        echo "::group::Running NPU Integration Tests"
        cargo test --tests --no-fail-fast
        echo "::endgroup::"
    
    - name: Check if builds
      run: cargo build --workspace --lib --verbose
    
    - name: Check formatting
      run: cargo fmt --all -- --check
    
    - name: Run Clippy (lib and tests only)
      run: cargo clippy --workspace --lib --tests -- -D warnings

  microbench:
    name: Burst Engine Microbench Gate
    runs-on: ubuntu-latest
    needs: [test]
    timeout-minutes: 30
    steps:
    - name: Checkout PR code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Install Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        toolchain: stable

    - name: Cache cargo registry
      uses: actions/cache@v3
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-cargo-

    - name: Run microbenchmarks (criterion)
      run: cargo bench -p feagi-npu-burst-engine --bench ci_microbench

    - name: Regression gate (perf compare)
      run: |
        cargo run --bin perf_compare -- \
          --baseline perf/ci_microbench_baseline.json \
          --criterion-dir target/criterion

  pre-release-checks:
    name: Pre-Release Test Suite
    runs-on: ubuntu-latest
    needs: [test, microbench]
    timeout-minutes: 60
    steps:
    - name: Checkout PR code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Install Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        toolchain: stable

    - name: Run pre-release checks (no publish)
      run: |
        chmod +x tests/pre_release_tests.sh
        tests/pre_release_tests.sh

  agent-sdk-live-contracts:
    name: Agent SDK Live HTTP Contract Tests
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
    - name: Checkout PR code
      uses: actions/checkout@v4

    - name: Install Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        toolchain: stable

    - name: Cache cargo registry
      uses: actions/cache@v3
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-cargo-

    - name: Build FEAGI HTTP API server (example)
      run: |
        set -euo pipefail
        cargo build -p feagi-api --example http_api_server

    - name: Start FEAGI HTTP API server (example) in background
      run: |
        set -euo pipefail
        echo "Starting feagi-api example server..."
        nohup ./target/debug/examples/http_api_server > feagi-api-server.log 2>&1 &
        echo $! > feagi-api-server.pid
        echo "PID: $(cat feagi-api-server.pid)"

    - name: Wait for FEAGI HTTP API server to be ready
      run: |
        set -euo pipefail
        for i in $(seq 1 180); do
          if curl -sf "http://127.0.0.1:8000/swagger-ui/" >/dev/null; then
            echo "Server is ready"
            exit 0
          fi
          sleep 1
        done
        echo "Server did not become ready in time"
        echo "Last 200 lines of server log:"
        tail -200 feagi-api-server.log || true
        exit 1

    - name: Run live HTTP contract tests (feagi-agent)
      env:
        FEAGI_API_HOST: 127.0.0.1
        FEAGI_API_PORT: "8000"
      run: |
        cargo test -p feagi-agent --test live_http_contract_tests --features sdk -- --nocapture

    - name: Upload server log (artifact)
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: feagi-api-server-log
        path: feagi-api-server.log
        if-no-files-found: warn

    - name: Stop FEAGI HTTP API server
      if: always()
      run: |
        set +e
        if [ -f feagi-api-server.pid ]; then
          kill "$(cat feagi-api-server.pid)" 2>/dev/null || true
        fi

  publish-local-sim:
    name: Publish Simulation (local packaged deps gate)
    runs-on: ubuntu-latest
    needs: [test, microbench, pre-release-checks]
    timeout-minutes: 45
    steps:
    - name: Checkout PR code (full history for diff)
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Install Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        toolchain: stable

    - name: Rust cache
      uses: Swatinem/rust-cache@v2
      with:
        shared-key: "publish-local-sim-staging-pr"
        save-if: true

    - name: Use committed unified versions (CI-only)
      shell: bash
      run: |
        set -euo pipefail
        echo "Using committed Cargo.toml versions without CI auto-bumps."

    - name: Fast-fail dependency feature validation
      shell: bash
      run: |
        set -euo pipefail
        python3 - <<'PY'
        from __future__ import annotations
        
        import re
        from pathlib import Path
        
        
        def load_manifest(path: Path) -> str:
            return path.read_text(encoding="utf-8")
        
        
        def parse_features(manifest: str) -> set[str]:
            features: set[str] = set()
            in_features = False
            for line in manifest.splitlines():
                if line.strip().startswith("[features]"):
                    in_features = True
                    continue
                if in_features and line.strip().startswith("[") and line.strip().endswith("]"):
                    break
                if not in_features:
                    continue
                m = re.match(r'^([A-Za-z0-9_-]+)\s*=\s*\[', line.strip())
                if m:
                    features.add(m.group(1))
            return features
        
        
        def parse_dependencies_with_features(manifest: str) -> dict[str, list[str]]:
            deps: dict[str, list[str]] = {}
            in_deps = False
            for line in manifest.splitlines():
                if line.strip().startswith("[dependencies]"):
                    in_deps = True
                    continue
                if in_deps and line.strip().startswith("[") and line.strip().endswith("]"):
                    break
                if not in_deps:
                    continue
                m = re.match(r'^([A-Za-z0-9_-]+)\s*=\s*\{([^}]*)\}', line.strip())
                if not m:
                    continue
                dep = m.group(1)
                body = m.group(2)
                features_m = re.search(r'features\s*=\s*\[([^\]]*)\]', body)
                if not features_m:
                    continue
                features_raw = features_m.group(1)
                features_list = [
                    f.strip().strip('"')
                    for f in features_raw.split(",")
                    if f.strip()
                ]
                if features_list:
                    deps[dep] = features_list
            return deps
        
        
        def collect_manifests(root: Path) -> list[Path]:
            manifests: list[Path] = [root / "Cargo.toml"]
            manifests += sorted((root / "crates").glob("*/Cargo.toml"))
            manifests += sorted((root / "crates" / "feagi-npu").glob("*/Cargo.toml"))
            return [m for m in manifests if m.exists()]
        
        
        def main() -> None:
            root = Path.cwd()
            manifests = collect_manifests(root)
        
            crate_features: dict[str, set[str]] = {}
            for mf in manifests:
                text = load_manifest(mf)
                name_m = re.search(r'(?m)^name\s*=\s*"([^"]+)"', text)
                if not name_m:
                    continue
                crate_features[name_m.group(1)] = parse_features(text)
        
            errors: list[str] = []
            for mf in manifests:
                text = load_manifest(mf)
                name_m = re.search(r'(?m)^name\s*=\s*"([^"]+)"', text)
                crate = name_m.group(1) if name_m else str(mf)
                deps = parse_dependencies_with_features(text)
                for dep, features in deps.items():
                    available = crate_features.get(dep)
                    if available is None:
                        continue
                    missing = [f for f in features if f not in available]
                    if missing:
                        errors.append(
                            f"{crate} depends on {dep} with missing features: {', '.join(missing)}"
                        )
        
            if errors:
                print("Dependency feature validation failed:")
                for err in errors:
                    print(f"  - {err}")
                raise SystemExit(1)
        
            print("Dependency feature validation passed.")
        
        
        if __name__ == "__main__":
            main()
        PY
    
    - name: Package and build published artifacts against local packaged dependencies
      shell: bash
      run: |
        set -euo pipefail
        echo "Packaging and building workspace crates with committed unified versions."

        # This directory is created at runtime in CI only (not committed).
        ROOT="/tmp/feagi_local_publish_sim"
        DRIVER="${ROOT}/driver"
        EXTRACTED="${ROOT}/extracted"
        mkdir -p "${DRIVER}/.cargo" "${EXTRACTED}"

        # Use the publish order baked into the existing smart publish script.
        # Keep this list in sync with scripts/publish-crates-smart.sh CRATE_ORDER.
        CRATE_ORDER=(
          "feagi-config"
          "feagi-npu-neural"
          "feagi-observability"
          "feagi-state-manager"
          "feagi-structures"
          "feagi-npu-runtime"
          "feagi-evolutionary"
          "feagi-serialization"
          "feagi-hal"
          "feagi-io"
          "feagi-npu-burst-engine"
          "feagi-sensorimotor"
          "feagi-npu-plasticity"
          "feagi-brain-development"
          "feagi-services"
          "feagi-agent"
          "feagi"
          "feagi-api"
        )

        crate_path_for() {
          case "$1" in
            feagi-observability) echo "crates/feagi-observability" ;;
            feagi-structures) echo "crates/feagi-structures" ;;
            feagi-config) echo "crates/feagi-config" ;;
            feagi-npu-neural) echo "crates/feagi-npu/neural" ;;
            feagi-npu-runtime) echo "crates/feagi-npu/runtime" ;;
            feagi-serialization) echo "crates/feagi-serialization" ;;
            feagi-state-manager) echo "crates/feagi-state-manager" ;;
            feagi-npu-burst-engine) echo "crates/feagi-npu/burst-engine" ;;
            feagi-npu-plasticity) echo "crates/feagi-npu/plasticity" ;;
            feagi-evolutionary) echo "crates/feagi-evolutionary" ;;
            feagi-brain-development) echo "crates/feagi-brain-development" ;;
            feagi-sensorimotor) echo "crates/feagi-sensorimotor" ;;
            feagi-services) echo "crates/feagi-services" ;;
            feagi-io) echo "crates/feagi-io" ;;
            feagi-api) echo "crates/feagi-api" ;;
            feagi-agent) echo "crates/feagi-agent" ;;
            feagi-hal) echo "crates/feagi-hal" ;;
            feagi) echo "." ;;
            *) return 1 ;;
          esac
        }

        # 0) Patch crates.io to local workspace for packaging validation.
        # This avoids crate resolution failures when new beta versions are not yet published.
        mkdir -p ".cargo"
        PATCH_LOCAL=".cargo/config.toml"
        {
          echo "[patch.crates-io]"
          for crate in "${CRATE_ORDER[@]}"; do
            path="$(crate_path_for "${crate}")" || continue
            [ -f "${path}/Cargo.toml" ] || continue
            echo "${crate} = { path = \"${GITHUB_WORKSPACE}/${path}\" }"
          done
        } > "${PATCH_LOCAL}"

        # 1) Produce .crate packages (manifest will be publish-style: no path/workspace deps).
        PACKAGES_DIR="${ROOT}/packages"
        mkdir -p "${PACKAGES_DIR}"
        for crate in "${CRATE_ORDER[@]}"; do
          path="$(crate_path_for "${crate}")" || continue
          [ -f "${path}/Cargo.toml" ] || continue
          echo "üì¶ cargo package -p ${crate}"
          cargo package --allow-dirty --no-verify --package "${crate}" --quiet
          version="$(awk -F'"' '/^version = / { print $2; exit }' "${path}/Cargo.toml")"
          crate_file="target/package/${crate}-${version}.crate"
          if [ ! -f "${crate_file}" ]; then
            echo "‚ùå Expected package not found: ${crate_file}"
            exit 1
          fi
          mv "${crate_file}" "${PACKAGES_DIR}/"
        done

        # 2) Extract packaged sources and build a [patch.crates-io] map to them.
        PATCH_FILE="${DRIVER}/.cargo/config.toml"
        {
          echo "[patch.crates-io]"
        } > "${PATCH_FILE}"

        for crate in "${CRATE_ORDER[@]}"; do
          path="$(crate_path_for "${crate}")" || continue
          [ -f "${path}/Cargo.toml" ] || continue

          version="$(awk -F'"' '/^version = / { print $2; exit }' "${path}/Cargo.toml")"
          if [ -z "${version}" ]; then
            echo "‚ùå Failed to read version for ${crate} from ${path}/Cargo.toml"
            exit 1
          fi

          crate_file="${PACKAGES_DIR}/${crate}-${version}.crate"
          if [ ! -f "${crate_file}" ]; then
            echo "‚ùå Expected package not found: ${crate_file}"
            exit 1
          fi

          dest="${EXTRACTED}/${crate}-${version}"
          rm -rf "${dest}"
          mkdir -p "${dest}"
          tar -xf "${crate_file}" -C "${dest}"

          # The tarball contains a single root folder: <name>-<version>/
          src_dir="${dest}/${crate}-${version}"
          if [ ! -f "${src_dir}/Cargo.toml" ]; then
            echo "‚ùå Extracted package missing Cargo.toml: ${src_dir}/Cargo.toml"
            exit 1
          fi

          echo "${crate} = { path = \"${src_dir}\" }" >> "${PATCH_FILE}"
        done

        echo ""
        echo "‚úÖ Patch map written to: ${PATCH_FILE}"
        echo ""

        # 3) Build each packaged crate against the packaged dependency set.
        # Run from DRIVER so the patch config applies.
        cd "${DRIVER}"

        for crate in "${CRATE_ORDER[@]}"; do
          # Find the extracted dir (we know the version from the repo Cargo.toml)
          path="$(crate_path_for "${crate}")" || continue
          [ -f "${GITHUB_WORKSPACE}/${path}/Cargo.toml" ] || continue

          version="$(awk -F'"' '/^version = / { print $2; exit }' "${GITHUB_WORKSPACE}/${path}/Cargo.toml")"
          manifest="${EXTRACTED}/${crate}-${version}/${crate}-${version}/Cargo.toml"
          if [ ! -f "${manifest}" ]; then
            echo "‚ùå Missing extracted manifest: ${manifest}"
            exit 1
          fi

          # Generate a lockfile for deterministic builds from the extracted manifest.
          cargo generate-lockfile --manifest-path "${manifest}"

          echo "üî® Building packaged crate: ${crate} (${version})"
          cargo build --manifest-path "${manifest}" --locked --quiet
        done

        echo ""
        echo "üéâ Local publish simulation build completed successfully."
